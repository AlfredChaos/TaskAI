### **任务调度排期算法：设计思路与理念**

#### 1. 核心理念 (Core Philosophy)

我的设计核心是**“紧迫度驱动，动态调整，兼顾多样性”**。

* **紧迫度驱动 (Urgency-Driven):** 算法的核心不是简单地看用户设置的“高、中、低”优先级，而是要计算一个动态的、量化的**“紧迫度分数 (Urgency Score)”**。这个分数会综合考虑项目的截止日期、剩余工作量和静态优先级。一个低优先级但明天就要截止的大型项目，其紧迫度可能远高于一个高优先级但截止日期在一个月后的小任务。

* **动态调整 (Dynamic Adjustment):** 调度不是一次性的静态过程。每天开始调度时，算法都应该重新评估所有待办任务的紧迫度。昨天看起来不紧急的任务，今天可能因为截止日期的临近而变得非常紧急。同时，对于逾期任务和延期项目，算法有明确的应对机制。

* **兼顾多样性 (Diversity-Conscious):** 为了避免连续多天只做一个类型的项目（例如，连续一周都在编程），算法在选择当天的任务时，会引入一个“多样性”因子。在紧迫度相差不大的情况下，优先选择一个当天还未安排过的项目类别的任务，促进工作内容的平衡。

#### 2. 数据结构设计 (Data Structure Design)

为了实现上述理念，我们需要清晰定义好我们的数据模型。

* **`Project` (项目):**
    * `project_id`: 唯一标识符
    * `name`: 项目名称
    * `category`: 项目类别 (如: '研发', '市场营销', '生活')
    * `priority`: 项目的静态优先级 (例如: 1-高, 2-中, 3-低)
    * `deadline`: 截止日期 (Date 对象)
    * `status`: 项目状态 ('active', 'delayed', 'completed')

* **`Task` (任务):**
    * `task_id`: 唯一标识符
    * `project_id`: 所属项目的ID
    * `name`: 任务名称
    * `estimated_hours`: 完成任务所需的总工时 (以0.5小时为单位的整数，例如4代表2小时)
    * `remaining_hours`: 剩余工时，初始值等于 `estimated_hours`
    * `status`: 任务状态 ('pending', 'overdue', 'completed')
    * `due_date`: 任务的截止日期 (Date 对象)
    * *注意：任务的优先级可以直接继承自其所属项目，简化管理。*

* **`Schedule` (排期表):**
    * 可以使用一个字典来表示，键是日期 (Date)，值是一个列表，列表中包含了当天被安排的 `Task` 片段。例如：`{ '2025-07-28': [ (task_A, 1.5h), (task_B, 2.0h) ] }`

* **`Queues` (队列):**
    * `overdue_queue`: 一个专门存放逾期任务的列表。这里的任务拥有绝对最高的调度优先权。
    * `delayed_projects`: 一个存放因超期而等待用户处理的项目的列表。

#### 3. 核心算法流程 (Core Algorithm Flow)

算法的执行可以分为两个阶段：**评估排序** 和 **每日填充**。

**阶段一：评估与排序 (Evaluation & Sorting)**

这是算法的大脑。每天开始调度前，我们都需要对所有`active`项目的`pending`状态的任务进行打分。

1.  **处理逾期任务:** 检查 `overdue_queue`。将队列中所有任务置于最高优先级，准备最先安排。

2.  **计算紧迫度分数 (Urgency Score):**
    为每一个**未完成的、未逾期的**任务计算一个分数。公式设计如下：
    $$
    \text{UrgencyScore} = (w_1 \times \text{PriorityFactor}) + (w_2 \times \text{DeadlineFactor}) + (w_3 \times \text{WorkloadFactor})
    $$
    * **`PriorityFactor` (优先级因子):** 将项目设定的高、中、低优先级转化为数值。例如，高=1.5, 中=1.0, 低=0.5。这个权重($w_1$)可以设得较高，以尊重用户的原始设定。
    * **`DeadlineFactor` (截止日期因子):** 这是体现“紧迫性”的关键。可以设计为：
        $$
        \text{DeadlineFactor} = \frac{1}{\max(1, \text{DaysUntilDeadline})}
        $$
        其中 `DaysUntilDeadline` 是今天到截止日期的天数。分母加1是为了避免除以零。当截止日期临近时，这个因子会急剧增大。
    * **`WorkloadFactor` (工作量因子):** 用于评估在剩余时间内完成任务的压力。
        $$
        \text{WorkloadFactor} = \frac{\text{ProjectRemainingHours}}{\max(1, \text{DaysUntilDeadline})}
        $$
        其中 `ProjectRemainingHours` 是该任务所属项目所有剩余任务的总工时。如果这个比率很大，意味着项目很可能延期，需要更高的紧迫度。
    * `w_1, w_2, w_3` 是权重系数，可以通过调试来优化，以平衡不同因子的影响。

3.  **生成待办列表:** 将所有待办任务（包括逾期任务）根据其计算出的 `UrgencyScore` 从高到低进行排序，形成一个总的待办任务列表。

**阶段二：每日排期与填充 (Daily Scheduling & Filling)**

1.  **初始化当天:**
    * 获取当天的可用总工时 (例如 8 小时)。
    * 创建一个空的集合 `categories_scheduled_today` 用于记录今天已经排了哪些类别的项目。

2.  **循环填充:**
    * **优先处理逾期:** 从 `overdue_queue` 中取出任务，按顺序排入今天的日程，直到逾期任务排完或当天时间用尽。
    * **处理常规任务:** 遍历排序后的待办任务列表。
    * **应用多样性规则:** 对于列表中的下一个任务，检查其项目类别是否已在 `categories_scheduled_today` 中。
        * 如果紧迫度最高的几个任务都属于同一类别，而这个类别今天已经安排过了，算法可以**向前看（look ahead）**几位，寻找一个紧迫度稍低但属于新类别的任务，并优先安排它。这可以设置为一个可配置的策略（例如，“如果分数差距小于10%，则优先选择新类别”）。
    * **分配时间片:**
        * 选择要安排的任务（已考虑多样性）。
        * 如果当天的剩余时间 >= 任务的剩余工时，则将整个任务排入，并更新任务状态为 `completed`。
        * 如果当天的剩余时间 < 任务的剩余工时，则将当天所有剩余时间分配给这个任务（以0.5小时为单位对齐），并更新任务的 `remaining_hours`。
    * **更新状态:** 更新当天的剩余可用时间，并将已安排的任务类别加入 `categories_scheduled_today`。
    * **重复:** 继续循环，直到当天时间用完，或者所有任务都已安排。

3.  **进入下一天:** 日期加一，重复**阶段二**，直到所有任务都被排入日程。

#### 4. 边界情况与后期处理 (Edge Cases & Post-Processing)

1.  **项目延期处理:** 在整个排期完成后，检查是否有项目的截止日期已经过去，但其仍有任务未完成。
    * 将这些项目 `status` 设为 `delayed`。
    * 将项目放入 `delayed_projects` 列表，等待用户更新其截止日期。一旦用户更新，项目状态变为 `active`，其任务会在下一次调度时被重新评估和排期。

2.  **无法完成的任务:** 如果即使排满了所有可用时间，一个任务的预计完成日期还是超过了其项目的截止日期，这就是一个**“预警”**。算法可以标记这类任务/项目，提示用户可能需要调整截止日期、增加每日工时或减少任务量。

